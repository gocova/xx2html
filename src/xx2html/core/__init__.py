"""Core transformation API for converting XLSX workbooks to HTML."""

import logging
import os
from importlib.metadata import PackageNotFoundError, version as get_installed_version
from string import Formatter
from tempfile import NamedTemporaryFile
from zipfile import ZipFile

from bs4 import BeautifulSoup, Comment
from openpyxl import load_workbook
from openpyxl.styles.differential import DifferentialStyleList

# Monkey patch!
from xx2html.core.cf import apply_cf_styles_in_soup
from xx2html.core.patches.openpyxl import apply_patches

from .incell import get_incell_css
from .links import update_links_in_soup
from .types import (
    ConditionalFormattingRelation,
    TransformResult,
    XlsxTransformCallable,
)
from .utils import cova_render_table, get_worksheet_contents
from .vm import get_incell_images_refs

# from .css import CssRegistry, create_get_css_components_from_cell
from condif2css.processor import process_conditional_formatting
from condif2css.themes import get_theme_colors
from condif2css.core import create_themed_css_color_resolver
from condif2css.color import argb_to_css
from condif2css.css import CssBuilder, CssRulesRegistry, create_get_css_from_cell

_PATCHES_APPLIED = False
_XX2HTML_VERSION: str | None = None
_REQUIRED_SHEET_TEMPLATE_FIELDS = {
    "enc_sheet_name",
    "sheet_name",
    "table_generated_html",
}
_REQUIRED_SHEETNAME_TEMPLATE_FIELDS = {"enc_sheet_name", "sheet_name"}
_REQUIRED_INDEX_TEMPLATE_FIELDS = {
    "sheets_generated_html",
    "sheets_names_generated_html",
    "source_filename",
    "fonts_html",
    "core_css_html",
    "user_css_html",
    "generated_css_html",
    "generated_incell_css_html",
    "safari_js",
    "conditional_css_html",
}


def _paths_refer_to_same_file(path_a: str, path_b: str) -> bool:
    try:
        return os.path.samefile(path_a, path_b)
    except OSError:
        return os.path.abspath(path_a) == os.path.abspath(path_b)


def _get_xx2html_version() -> str:
    global _XX2HTML_VERSION
    if _XX2HTML_VERSION is not None:
        return _XX2HTML_VERSION
    try:
        _XX2HTML_VERSION = get_installed_version("xx2html")
    except PackageNotFoundError:
        _XX2HTML_VERSION = "0.0.0"
    return _XX2HTML_VERSION


def _inject_generator_metadata(soup: BeautifulSoup, package_version: str) -> None:
    generator_content = f"xx2html {package_version}"

    head = soup.head
    if head is not None:
        generator_meta = head.find(
            "meta", attrs={"name": "generator"}
        )
        if generator_meta is None:
            head.append(
                soup.new_tag(
                    "meta",
                    attrs={"name": "generator", "content": generator_content},
                )
            )
        else:
            generator_meta["content"] = generator_content

    body = soup.body
    if body is None:
        return

    expected_comment = f"Generated by xx2html {package_version}"
    for existing_comment in body.find_all(
        string=lambda value: isinstance(value, Comment)
    ):
        if expected_comment in str(existing_comment):
            return

    body.insert(0, Comment(f" {expected_comment} "))


def _extract_template_fields(template: str) -> set[str]:
    fields: set[str] = set()
    for _, field_name, _, _ in Formatter().parse(template):
        if field_name is None:
            continue
        root_field_name = field_name.split(".", 1)[0].split("[", 1)[0]
        if root_field_name:
            fields.add(root_field_name)
    return fields


def _validate_template_fields(
    template_name: str,
    template_value: str,
    required_fields: set[str],
) -> None:
    missing_fields = sorted(required_fields - _extract_template_fields(template_value))
    if missing_fields:
        missing_fields_csv = ", ".join(missing_fields)
        raise ValueError(
            f"{template_name} is missing required placeholders: {missing_fields_csv}"
        )


def _validate_optional_limit(name: str, value: int | None) -> int | None:
    if value is None:
        return None
    if isinstance(value, bool) or not isinstance(value, int):
        raise TypeError(f"{name} must be an integer or None.")
    if value < 1:
        raise ValueError(f"{name} must be >= 1.")
    return value


def _write_html_atomically(dest: str, html: str) -> None:
    temp_output_path = None
    try:
        destination_dir = os.path.dirname(os.path.abspath(dest))
        with NamedTemporaryFile(
            "w",
            encoding="utf-8",
            dir=destination_dir,
            delete=False,
            prefix=".xx2html-",
            suffix=".tmp",
        ) as temp_output_file:
            temp_output_path = temp_output_file.name
            temp_output_file.write(html)

        os.replace(temp_output_path, dest)
        temp_output_path = None
    finally:
        if temp_output_path is not None and os.path.exists(temp_output_path):
            os.unlink(temp_output_path)


def _build_cf_style_relations(
    workbook,
    conditional_formatting_rule_details: dict,
    get_cf_css_from_diff,
) -> list[ConditionalFormattingRelation]:
    cf_style_relations: list[ConditionalFormattingRelation] = []
    if not (
        hasattr(workbook, "_differential_styles")
        and isinstance(
            workbook._differential_styles,  # type: ignore
            DifferentialStyleList,
        )
    ):
        return cf_style_relations

    differential_styles = workbook._differential_styles  # type: ignore
    differential_styles_list = getattr(differential_styles, "styles", None)
    differential_styles_count = (
        len(differential_styles_list)
        if isinstance(differential_styles_list, list)
        else None
    )

    for _, details in conditional_formatting_rule_details.items():
        sheet_name, cell_ref, _, dxf_id, _ = details
        if not isinstance(dxf_id, int):
            logging.warning(
                "Transform (wb|cf): non-integer dxf_id for %s!%s: %r",
                sheet_name,
                cell_ref,
                dxf_id,
            )
            continue
        if dxf_id < 0:
            logging.warning(
                "Transform (wb|cf): negative dxf_id for %s!%s: %d",
                sheet_name,
                cell_ref,
                dxf_id,
            )
            continue
        if isinstance(differential_styles_count, int) and dxf_id >= differential_styles_count:
            logging.warning(
                "Transform (wb|cf): dxf_id out of range for %s!%s: %d (size=%d)",
                sheet_name,
                cell_ref,
                dxf_id,
                differential_styles_count,
            )
            continue

        try:
            if isinstance(differential_styles_list, list):
                differential_style = differential_styles_list[dxf_id]
            else:
                differential_style = differential_styles[dxf_id]
        except (IndexError, KeyError, TypeError):
            logging.warning(
                "Transform (wb|cf): unable to resolve dxf_id for %s!%s: %r",
                sheet_name,
                cell_ref,
                dxf_id,
            )
            continue
        class_names = get_cf_css_from_diff(
            differential_style,
            is_important=True,
        )
        cf_style_relations.append((sheet_name, cell_ref, class_names))

    return cf_style_relations


def apply_openpyxl_patches() -> None:
    """Apply required openpyxl monkey patches once per process."""
    global _PATCHES_APPLIED
    if _PATCHES_APPLIED:
        return
    logging.debug("xx2html: applying required openpyxl monkey patches")
    apply_patches()
    _PATCHES_APPLIED = True


# Explicitly apply monkey patches required for vm-aware parsing.
apply_openpyxl_patches()


def create_xlsx_transform(
    sheet_html: str,
    sheetname_html: str,
    index_html: str,
    fonts_html: str,
    core_css: str,
    user_css: str,
    safari_js: str,
    update_local_links: bool = True,
    # prepare_iframe_noscript: bool = True,
    apply_cf: bool = False,
    fail_ok: bool = True,
    max_sheets: int | None = None,
    max_rows: int | None = None,
    max_cols: int | None = None,
    raise_on_error: bool = False,
) -> XlsxTransformCallable:
    """Build and return a configured XLSX-to-HTML transform function.

    The returned callable takes `(source, dest, locale)` and writes a complete
    HTML document to `dest`.
    """
    _validate_template_fields(
        "sheet_html", sheet_html, _REQUIRED_SHEET_TEMPLATE_FIELDS
    )
    _validate_template_fields(
        "sheetname_html", sheetname_html, _REQUIRED_SHEETNAME_TEMPLATE_FIELDS
    )
    _validate_template_fields(
        "index_html", index_html, _REQUIRED_INDEX_TEMPLATE_FIELDS
    )
    validated_max_sheets = _validate_optional_limit("max_sheets", max_sheets)
    validated_max_rows = _validate_optional_limit("max_rows", max_rows)
    validated_max_cols = _validate_optional_limit("max_cols", max_cols)

    def transform_xlsx(
        source: str, dest: str, locale: str
    ) -> TransformResult:
        """Transform one XLSX file into one HTML file."""
        workbook = None
        workbook_archive = None
        try:
            if _paths_refer_to_same_file(source, dest):
                raise ValueError("Source and destination paths must be different.")

            sheet_navigation_links = []
            sheet_html_sections = []

            logging.info(f"Transform (wb): Reading '{source}' as xlsx file...")
            workbook = load_workbook(source, data_only=True, rich_text=True)

            logging.debug("Transform (wb|css): Reading theme colors...")
            theme_argb_palette = get_theme_colors(workbook)
            pre_get_css_color = create_themed_css_color_resolver(theme_argb_palette)

            def get_css_color(color):
                argb_color = pre_get_css_color(color)
                if argb_color is None:
                    return None
                return argb_to_css(argb_color)

            css_builder = CssBuilder(get_css_color)
            css_registry = CssRulesRegistry()
            get_css_from_cell = create_get_css_from_cell(
                css_registry, css_builder=css_builder
            )

            css_cf_registry = CssRulesRegistry(prefix="xx2h_cf")
            get_cf_css_from_diff = create_get_css_from_cell(
                css_registry=css_cf_registry, css_builder=css_builder
            )

            logging.debug("Transform (wb|incell): Reading incell images...")
            incell_images_refs = {}
            try:
                workbook_archive = ZipFile(source, "r")
                incell_images_refs, incell_error = get_incell_images_refs(
                    workbook_archive
                )
                if incell_error is not None:
                    raise incell_error
                logging.info("Transform (wb|incell): Reading complete!")
            except Exception as incell_exc:
                logging.warning(
                    "Transform (wb|incell): Unable to read incell images due to: %r",
                    incell_exc,
                )
                if workbook_archive is not None:
                    workbook_archive.close()
                    workbook_archive = None

            vm_ids = set()
            vm_ids_dimension_references = dict()
            vm_cell_vm_ids = dict()

            visible_sheet_names = [
                sheet_name
                for sheet_name in workbook.sheetnames
                if workbook[sheet_name].sheet_state == "visible"
            ]
            if validated_max_sheets is not None:
                visible_sheet_names = visible_sheet_names[:validated_max_sheets]

            encoded_sheet_names = dict()
            conditional_formatting_rule_details = {}

            for sheet_name in visible_sheet_names:
                worksheet = workbook[sheet_name]
                worksheet_index = workbook.index(worksheet)
                encoded_sheet_name = f"sheet_{hex(worksheet_index)[2:].zfill(3)}"
                encoded_sheet_names[sheet_name] = encoded_sheet_name

                logging.info(
                    f"Application (ws): Sheet[{worksheet_index}]:'{sheet_name}' (enc_sheet_name: {encoded_sheet_name}) -> is visible"
                )

                contents = get_worksheet_contents(
                    worksheet,
                    css_rules_registry=css_registry,
                    css_builder=css_builder,
                    get_css_from_cell=get_css_from_cell,
                    locale=locale,
                    ws_index=worksheet_index,
                    max_rows=validated_max_rows,
                    max_cols=validated_max_cols,
                )

                logging.info(f" {encoded_sheet_name} --> vm_ids: {contents['vm_ids']}")
                vm_ids.update(contents["vm_ids"])
                vm_ids_dimension_references.update(
                    contents["vm_ids_dimension_references"]
                )
                vm_cell_vm_ids.update(contents["vm_cell_vm_ids"])

                sheet_html_sections.append(
                    sheet_html.format(
                        enc_sheet_name=encoded_sheet_name,
                        sheet_name=sheet_name,
                        table_generated_html=cova_render_table(contents),
                    )
                )

                sheet_navigation_links.append(
                    sheetname_html.format(
                        enc_sheet_name=encoded_sheet_name, sheet_name=sheet_name
                    )
                )

                if apply_cf:
                    logging.info(
                        f"Application (wb|cf): Processing conditional formatting for '{sheet_name}'"
                    )
                    conditional_formatting_rule_details.update(
                        process_conditional_formatting(worksheet, fail_ok=fail_ok)
                    )

            generated_css = "\n".join(css_registry.get_rules())

            if workbook_archive is not None:
                logging.debug(
                    "Transform (wb|incell): Preparing incell images output..."
                )
                generated_incell_css = get_incell_css(
                    vm_ids,
                    vm_ids_dimension_references,
                    vm_cell_vm_ids,
                    incell_images_refs,
                    workbook_archive,
                )
            else:
                generated_incell_css = ""

            logging.info(
                f"Transform (html|1): Pass 1 --> Preparing {len(conditional_formatting_rule_details)} conditional formatting styles..."
            )
            cf_style_relations = _build_cf_style_relations(
                workbook,
                conditional_formatting_rule_details,
                get_cf_css_from_diff,
            )
            logging.debug(
                f"Transform: Resulting conditional formatting styles: {cf_style_relations}"
            )

            logging.info("Transform (html|2): Pass 2 --> Preparing html")
            css_rules = "\n".join(css_cf_registry.get_rules())
            html = (
                index_html.format(
                    sheets_generated_html="\n".join(sheet_html_sections),
                    sheets_names_generated_html="\n".join(sheet_navigation_links),
                    source_filename=source,
                    fonts_html=fonts_html,
                    core_css_html=f"<style>{core_css}</style>",
                    user_css_html=f"<style>{user_css}</style>",
                    generated_css_html=f"<style>{generated_css}</style>",
                    generated_incell_css_html=f"<style>{generated_incell_css}</style>",
                    safari_js=f"<script>{safari_js}</script>",
                    conditional_css_html=f"<style>/*conditional formatting*/\n{css_rules}</style>",
                )
                .replace('"$"', "$")
                .replace('"-"', "-")
            )

            logging.info("Transform (html|3): Pass 3 --> Updating links and CF...")
            soup = BeautifulSoup(html, "lxml")
            _inject_generator_metadata(soup, _get_xx2html_version())
            update_links_in_soup(
                soup,
                encoded_sheet_names,
                update_local_links=update_local_links,
            )
            apply_cf_styles_in_soup(soup, cf_style_relations)
            final_html = str(soup)

            logging.info(f"Transform (out): Writing output atomically to '{dest}'")
            _write_html_atomically(dest, final_html)

            logging.info("Transform: Done!")
            return (True, None)
        except Exception as exc:
            logging.exception("Transform failed for '%s' -> '%s'", source, dest)
            if raise_on_error:
                raise
            return (False, repr(exc))
        finally:
            if workbook_archive is not None:
                logging.info("Transform (wb|incell): Closing archive...")
                workbook_archive.close()
            if workbook is not None:
                logging.info(f"Transform (wb): Closing wb: {source}")
                workbook.close()

    return transform_xlsx
